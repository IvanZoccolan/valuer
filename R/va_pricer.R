#Pricing engine of a VA product


########### DESIGN  ###################################################################################
#The engine should return both the static and mixed approach calculation
#It should since we want to compare results from both approaches applied to the same simulated paths
#Define a new base class va_engine and specialize it whenever we change the way we simulate the underlying asset
#(e.g Black Scholes va_bs_engine or jump diffusion va_jump_engine etc).
#The get_one_path method will generate the path which has to be saved into an internal matrix
#Need a  private field  with the underlying asset paths matrix

#If using stochastic interest rate the implementation of discounts active binding has to be changed.
#If we used as is  I would use a sample path for interest rate for discounting which would be different
#from the one used to generate the underlying asset path.
#So the get_one_path will generate also the interest rate path
#A private field with a matrix to hold the simulated interest rate paths needs to be added
#Each row of the matrix will hold a interest rate path
#get_one_path will populate both the asset path matrix and the interest rate path matrix.
#the discounts binding will return the discount factors (calculate the integrals) based on
#the interest rate paths saved in the private interest rate matrix.

#A private field of the engine needs to save the cash flows generated by the product.
#Since cash flow lengths may differ, this private field will be a list of numeric vectors (the cash flows)

#VA pricer engine will have an active binding to simulate the death time.
#Implementation of the VA pricer must be changed if we want stochastic mortality or deterministic mortality.
#Deterministic will be the first choice.
#The pricer will pass the death time to the cash_flows method of the VA product so that it will return the
#cash_flows up to death time.

#########################################################################################################3


va_engine <- R6Class("va_engine",
                         public = list(
                           initialize = function(product, interest, age, c1, c2){
                             if(!missing(product))
                               if (inherits(product, "va_product")) {
                                 private$the_product <- product
                               } else stop(error_msg_1("va_product"))
                             else stop(error_msg_1("va_product"))

                             if(!missing(interest))
                               if(inherits(interest, "parameters")) {
                                 private$r <- interest
                               } else stop(error_msg_1("parameters"))
                             else stop(error_msg_1("parameters"))

                             if(!missing(age))
                               if (is_positive_integer(age))
                                 private$the_age <- age
                               else stop(error_msg_4("age"))
                             else private$the_age <- 60

                             if(!missing(c1))
                               if (is_positive_scalar(c1))
                                 private$mu_1 <- c1
                               else stop(error_msg_5("c1"))
                             else private$mu_1 <- 90.43

                             if(!missing(c2))
                               if (is_positive_scalar(c2))
                                 private$mu_2 <- c2
                               else stop(error_msg_5("c2"))
                             else private$mu_2 <- 10.36

                           },

                           get_one_path = function(){},

                           get_mortality_path = function(){

                            age <- private$the_age
                            c1 <- private$mu_1
                            c2 <- private$mu_2

                            t_yrs  <- private$the_product$times_in_yrs()

                            #Deterministic intensity of mortality ( Weibull )

                            (c1 ^ (-c2)) * c2 * ((age + t_yrs) ^ (c2 - 1))

                           },

                           run_simulation = function(the_gatherer, number_of_paths){
                             res <- sapply(seq(number_of_paths), function(index) {
                               spot_values <- self$get_one_path()
                               this_value <- self$discount_one_path(spot_values)
                             })
                             the_gatherer$dump_result(res)
                           },

                           discount_one_path = function(spot_values){
                             these_cash_flows <- private$the_product$cash_flows(spot_values)
                             sum(these_cash_flows$get_amounts() * self$discounts)
                           }
                         ),
                         active = list(
                           discounts  = function(){
                             cf_times <- private$the_product$cash_flow_times()
                             t0 <- cf_times[1]
                             log_discounts <- sapply(cf_times, function(t) -private$r$integral(t0, t))
                             exp(log_discounts)
                           }
                         ),
                         private = list(
                           the_product = "va_product",
                           r = "parameters",
                           #Initial age
                           the_age = 60,
                           mu_1 = 90.43,
                           mu_2 = 10.36
                         )
)










va_bs_engine <- R6::R6Class("va_bs_engine", inherit= exotic_engine,
                                public = list(
                                  initialize = function(product, interest, spot, volatility, dividends){
                                    if(!missing(product))
                                      if (inherits(product, "va_product")){
                                        private$the_product <- product
                                        private$times <- product$get_times()
                                        private$no_time_intervals <- length(private$times) - 1
                                        private$drifts <- numeric(private$no_time_intervals)
                                        private$standard_deviations <- numeric(private$no_time_intervals)
                                        private$variates <- numeric(private$no_time_intervals)
                                      } else stop(error_msg_1("va_product"))
                                    else stop(error_msg_1("va_product"))

                                    if(!missing(interest))
                                      if(inherits(interest, "parameters")){
                                        private$r <- interest
                                      } else stop(error_msg_1("parameters"))
                                    else stop(error_msg_1("parameters"))

                                    if(!missing(spot))
                                      if (is_positive_scalar(spot)){
                                        private$spot <- spot
                                      } else stop(error_msg_3)
                                    else stop(error_msg_3)

                                    if(!missing(volatility) & !missing(dividends)){
                                      if (inherits(volatility, "parameters") & inherits(dividends, "parameters")){
                                        for (j in seq(private$no_time_intervals)){
                                          this_variance <- volatility$integral_square(private$times[j], private$times[j+1])
                                          private$drifts[j] <- interest$integral(private$times[j], private$times[j+1])
                                          - dividends$integral(private$times[j], private$times[j+1])
                                          - 0.5 * this_variance
                                          private$standard_deviations[j] <- sqrt(this_variance)
                                        }
                                      }else stop(error_msg_2("parameters"))
                                    } else stop(error_msg_2("parameters"))
                                  },

                                  get_one_path = function(){

                                    private$variates <- rnorm(private$no_time_intervals)
                                    current_log_spot <- private$drifts +
                                      private$standard_deviations * private$variates
                                    current_log_spot <- cumsum(current_log_spot)
                                    c(spot, spot*exp(current_log_spot))

                                  }
                                ),
                                private = list(
                                  times = "timeDate",
                                  drifts = "numeric",
                                  standard_deviations = "numeric",
                                  variates = "numeric",
                                  spot = "numeric",
                                  no_time_intervals = "numeric"
                                )
)





