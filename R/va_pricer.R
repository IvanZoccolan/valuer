#Pricing engine of a VA product


##########################DESIGN  COMMENTS ####################################
#
#The engine should return both the static and mixed approach calculation.
#It should since we want to compare results from both approaches applied to
#the same simulated paths. Define a new base class va_engine and specialize it
#whenever we change the way we simulate the underlying asset (e.g Black Scholes
#va_bs_engine or jump diffusion va_jump_engine etc). The get_one_path method will
#generate the path which has to be saved into an internal matrix. Need a  private
#field  with the underlying asset paths matrix.
#
#If using stochastic interest rate the implementation of discounts active binding
#has to be changed. If we used as is  I would use a sample path for interest rate
#for discounting which would be different from the one used to generate
#the underlying asset path. So the get_one_path will generate also
#the interest rate path.
#A private field with a matrix to hold the simulated interest rate paths
#needs to be added. Each row of the matrix will hold a interest rate path
#get_one_path will populate both the asset path matrix and
#the interest rate path matrix.
#the discounts binding will return the discount factors (calculate the integrals)
#based on the interest rate paths saved in the private interest rate matrix.

#A private field of the engine needs to save the cash flows generated by
#the product.
#Since cash flow lengths may differ, this private field will be a list of
#numeric vectors (the cash flows)

#VA pricer engine will have  to simulate the death times
# public method death_time will do that. The function will return the
#the index of the timeDate sequence of the product time-line corresponding to
#the death time or Inf in case the death time is after the maturity of
#the product.
#This death_times method will get from  a public method (get_mortality) the
#simulated paths  of the integrals of the intensity of mortality over the product time-line.
#It will use the integrals to simulate the death time.
#get_mortality() is a standard interface of the base VA engine
#which will be implemented in sub classes depending we want  stochastic mortality
#or deterministic mortality.
#Deterministic will be the first choice. In this case the intensity of mortality
#and intensity of mortality integral paths don't change so they will be calculated
#during initialization and saved into a private field that can be used later on
#( e.g: by  death_time).
#So a sub class for deterministic mortality will have a private field to hold
#the mortality paths and the initialize method must be overwritten to call
#get_mortality() and save the paths once for all. The implementation of death_time
#will be overwritten to get the pre-calculated mortality integrals
#from the private field.
#Sub classes implementing stochastic mortality will have to call get_mortality()
#to get a new simulated path each time.
#In this case the base class implementation of death_time
#does not need to be changed.
#The pricer will pass the death time to the cash_flows method of the VA product
#so that it will return the cash_flows up to death time.
######################END DESIGN  COMMENTS#####################################

#' Generic Variable Annuity  pricer engine
#' @description  Class providing an interface for a generic VA pricer engine.
#' See \bold{References} for a description of variable annuities life insurance products, their guarantees and fee structures.
#' @docType class
#' @importFrom R6 R6Class
#' @importClassesFrom timeDate timeDate
#' @importFrom timeDate timeDate timeSequence
#' @importFrom orthopolynom laguerre.polynomials
#' @importFrom polynom polynomial
#' @importFrom RcppEigen fastLmPure
#' @export



va_engine <- R6Class("va_engine",
 public = list(
  initialize = function(product, interest, age, c1, c2){

   if(!missing(product))
    if (inherits(product, "va_product")) {
     private$the_product <- product
    } else stop(error_msg_1(" va_product"))
   else stop(error_msg_1(" va_product"))

   if(!missing(interest))
    if(inherits(interest, "parameters")) {
     private$r <- interest
    } else stop(error_msg_1("parameters"))
   else stop(error_msg_1("parameters"))

   if(!missing(age))
    if (is_positive_integer(age))
     private$the_age <- age
    else stop(error_msg_4("age"))
   else private$the_age <- 60

   if(!missing(c1))
    if (is_positive_scalar(c1))
    private$mu_1 <- c1
    else stop(error_msg_5("c1"))
   else private$mu_1 <- 90.43

   if(!missing(c2))
    if(is_positive_scalar(c2))
    private$mu_2 <- c2
    else stop(error_msg_5("c2"))
   else private$mu_2 <- 10.36
  },
  get_mortality = function(){
   times <- private$the_product$get_times()
   x <- rep(0, length(times))
  },
  death_time = function(){
    mu_integrals <- self$get_mortality()
    ind <- which(mu_integrals > rexp(1))
    if (length(ind) != 0)
      res <- min(ind)
    else res <- lenght(mu_integrals)
    res
  },
  get_fund_path = function(){},
  simulate_fin_paths = function(npaths){
   #This should be moved into the sub class
   #while the base class just defines the interface
   cf_times <- private$the_product$get_times()
   private$fund <- t(vapply(seq(npaths), function(index) {
    self$get_fund_path()
   }, FUN.VALUE = vector("numeric", length(cf_times))))

   t0 <- cf_times[1]
   log_discounts <- sapply(cf_times, function(t) -private$r$integral(t0, t))
   private$discounts <- exp(log_discounts)

  },
  do_static = function(the_gatherer, npaths, simulate = TRUE){

   times <- private$the_product$get_times()
   m = length(times)
   ind <- seq(npaths)

   if(simulate){
    #Simulates financials
    self$simulate_fin_paths(npaths)
    #Simulates times of death
    private$tau <- sapply(ind, function(i){
     self$death_time()
    })
   }

   #Initial cash flow matrix
   cash <- matrix(NA, nrow = npaths, ncol = m)
   old_penalty <- private$the_product$get_penalty()
   private$the_product$set_penalty(penalty=1)
   for (i in ind){
    cash[i, ] <- private$the_product$cash_flows(private$fund[i, ], private$tau[i])
   }
   res <- sapply(ind, function(i){
     sum(cash[i, 1:private$tau[i]] *
           self$get_discount(i, 1:private$tau[i]))
   })
   the_gatherer$dump_result(res)
   private$the_product$set_penalty(penalty=old_penalty)
  },
  do_mixed = function(the_gatherer, npaths, degree = 3, freq = "3m", simulate=TRUE){
   times <- private$the_product$get_times()
   m = length(times)
   ind <- seq(npaths)
   if(simulate){
   #Simulates financials
   self$simulate_fin_paths(npaths)
   #Simulates times of death
   private$tau <- sapply(ind, function(i){
     self$death_time()
   })
   }
   #Initial cash flow matrix
   cash <- matrix(NA, nrow = npaths, ncol = m)
   for (i in ind){
     cash[i, ] <- private$the_product$cash_flows(private$fund[i, ], private$tau[i])
   }
   #Initial surrender times vector
   sur_ts <- private$tau
   ##
   surrender_range <- c(1, private$the_product$surrender_times(freq))
   survival_times <- private$the_product$survival_benefit_times()
   tt <- c(surrender_range, survival_times)
   for(i in ind) cash[i, -sort(unique(c(tt, private$tau[i])))] <- 0

   for(t in rev(surrender_range)){
    if(!any(t == survival_times)){
     h_t <- which(private$tau > t)
     #Continuation value at time t
     c_t <- sapply(h_t, function(i){
       sum(cash[i, (t+1):sur_ts[i]] *
        self$get_discount(i, (t+1):sur_ts[i]) / self$get_discount(i, t))
       })
     #### Regression ####
     #Regressors
     x_t <- self$bases(h_t, t, degree)
     #Estimated continuation values
     chat_t <- RcppEigen::fastLmPure(x_t, c_t)$fitted.values
     #### Comparison between surrender values and estimated
     #### continuation values ####
     for (i in seq_along(h_t))
       if (cash[h_t[i], t] > chat_t[i])
         sur_ts[h_t[i]] <- t
     else cash[h_t[i], t] <- 0
    }
   }

   res <- sapply(seq_along(sur_ts), function(i) {
     sum(cash[i, 1:sur_ts[i]] *
       self$get_discount(i, 1:sur_ts[i]))
     })

   the_gatherer$dump_result(res)
  },
  get_discount = function(i,j) private$discounts[j],
  bases = function(paths, time, degree){
    NULL
    #Interface to get Laguerre polynomials of  state variables.
    #It is implemented in sub classes since state variables
    #may differ depending on the dynamics of financial and
    #mortality processes.
    #For example if we're modeling just the undelying fund as
    #a stochastic process (all rest deterministic), the state variable
    #process will be just the fund, no need to include interest rate or
    #mortality
    #paths numeric vector of indexes of the financial path processes
    #t numeric scalaer with the time index
    #degree is a positive scalaer with the max degree of the Laguerre
    #polynomials
  }
 ),
 private = list(
  the_product = "va_product",
  r = "parameters",
  #Initial age
  the_age = 60,
  mu_1 = 90.43,
  mu_2 = 10.36,
  fund = "matrix",
  discounts = "numeric",
  tau = "numeric"
 )
)


#Variable annuity pricing engine with the underlying reference fund model with a GBM
#and the intensity of mortality is modeled by the Weibull mortality function

#'@export

va_bs_engine <- R6::R6Class("va_bs_engine", inherit = va_engine,
 public = list(
  initialize = function(product, interest, age, c1, c2, spot, volatility, dividends){
   if(!missing(product))
    if (inherits(product, "va_product")){
     private$the_product <- product
     private$times <- product$get_times()
     private$no_time_intervals <- length(private$times) - 1
     private$drifts <- numeric(private$no_time_intervals)
     private$standard_deviations <- numeric(private$no_time_intervals)
     private$variates <- numeric(private$no_time_intervals)
    } else stop(error_msg_1("va_product"))
   else stop(error_msg_1("va_product"))

   if(!missing(interest))
    if(inherits(interest, "parameters")){
     private$r <- interest
    } else stop(error_msg_1("parameters"))
   else stop(error_msg_1("parameters"))

   if(!missing(age))
    if (is_positive_integer(age))
     private$the_age <- age
    else stop(error_msg_4("age"))
   else private$the_age <- 60

   if(!missing(c1))
    if (is_positive_scalar(c1))
      private$mu_1 <- c1
    else stop(error_msg_5("c1"))
   else private$mu_1 <- 90.43

   if(!missing(c2))
    if(is_positive_scalar(c2))
      private$mu_2 <- c2
    else stop(error_msg_5("c2"))
   else private$mu_2 <- 10.36

   if(!missing(spot))
    if (is_positive_scalar(spot)){
     private$spot <- spot
    } else stop(error_msg_3)
   else stop(error_msg_3)

   if(!missing(volatility) & !missing(dividends)){
    if (inherits(volatility, "parameters") & inherits(dividends, "parameters")){
     for (j in seq(private$no_time_intervals)){
      this_variance <- volatility$integral_square(private$times[j], private$times[j+1])
      private$drifts[j] <- interest$integral(private$times[j], private$times[j+1])
      - dividends$integral(private$times[j], private$times[j+1])
      - 0.5 * this_variance
      private$standard_deviations[j] <- sqrt(this_variance)
     }
    }else stop(error_msg_2("parameters"))
   } else stop(error_msg_2("parameters"))

   private$mu_integrals <- self$get_mortality()
  },
  get_fund_path = function(){
   private$variates <- rnorm(private$no_time_intervals)
   current_log_spot <- private$drifts +
            private$standard_deviations * private$variates
   current_log_spot <- cumsum(current_log_spot)
   c(spot, spot*exp(current_log_spot))
  },
  discount_one_path = function(spot_values){
   these_cash_flows <- private$the_product$cash_flows(spot_values)
   sum(these_cash_flows * private$discount_factors)
  },
  get_mortality = function(){
   age <- private$the_age
   c1 <- private$mu_1
   c2 <- private$mu_2
   times <- private$the_product$get_times()
   t_yrs  <- private$the_product$times_in_yrs()
   #Deterministic intensity of mortality ( Weibull )
   mu <- (c1 ^ (-c2)) * c2 * ((age + t_yrs) ^ (c2 - 1))
   #Integrals of the intensity of mortality
   dt <- diff(t_yrs)
   mu_ <- head(mu, -1)
   mu_integrals <- cumsum(c(0, mu_ * dt))
   mu_integrals
  },
  death_time = function(){
    ind <- which(private$mu_integrals > rexp(1))
    if (length(ind) != 0)
      res <- min(ind)
    else res <- length(private$times)
    res
  },
  get_discount = function(i,j) private$discounts[j],
  bases = function(paths, time, degree){
    #Interface to get Laguerre polynomials of  state variables.
    #It is implemented in sub classes since state variables
    #may differ depending on the dynamics of financial and
    #mortality processes.
    #For example if we're modeling just the undelying fund as
    #a stochastic process (all rest deterministic), the state variable
    #process will be just the fund, no need to include interest rate or
    #mortality
    #paths numeric vector of indexes of the financial path processes
    #t numeric scalaer with the time index
    #degree is a positive scalaer with the max degree of the Laguerre
    #polynomials

    res <- orthopolynom::laguerre.polynomials(degree,normalized=TRUE)
    x <- private$fund[paths, time]
    #Normalizes to avoid underflows in calculating
    #the exponential below.
    x <- x / private$the_product$get_premium()

    sapply(seq_along(res), function(i){
      exp(-0.5 * x) * (as.function(res[[i]])(x))
    })
  },
  get_fund_paths = function(){
    #To be removed. Debug only
    private$fund}
 ),
 private = list(
  times = "timeDate",
  drifts = "numeric",
  standard_deviations = "numeric",
  variates = "numeric",
  spot = "numeric",
  no_time_intervals = "numeric",
  mu_integrals = "numeric"
    )
)





