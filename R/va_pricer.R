#Pricing engine of a VA product


##########################DESIGN  COMMENTS ####################################
#
#The engine should return both the static and mixed approach calculation.
#It should since we want to compare results from both approaches applied to
#the same simulated paths. Define a new base class va_engine and specialize it
#whenever we change the way we simulate the underlying asset (e.g Black Scholes
#va_bs_engine or jump diffusion va_jump_engine etc). The get_one_path method will
#generate the path which has to be saved into an internal matrix. Need a  private
#field  with the underlying asset paths matrix.
#
#If using stochastic interest rate the implementation of discounts active binding
#has to be changed. If we used as is  I would use a sample path for interest rate
#for discounting which would be different from the one used to generate
#the underlying asset path. So the get_one_path will generate also
#the interest rate path.
#A private field with a matrix to hold the simulated interest rate paths
#needs to be added. Each row of the matrix will hold a interest rate path
#get_one_path will populate both the asset path matrix and
#the interest rate path matrix.
#the discounts binding will return the discount factors (calculate the integrals)
#based on the interest rate paths saved in the private interest rate matrix.

#A private field of the engine needs to save the cash flows generated by
#the product.
#Since cash flow lengths may differ, this private field will be a list of
#numeric vectors (the cash flows)

#VA pricer engine will have  to simulate the death times
# public method death_time will do that. The function will return the
#the index of the timeDate sequence of the product time-line corresponding to
#the death time or Inf in case the death time is after the maturity of
#the product.
#This death_times method will get from  a public method (get_mortality) the
#simulated paths  of the integrals of the intensity of mortality over the product time-line.
#It will use the integrals to simulate the death time.
#get_mortality() is a standard interface of the base VA engine
#which will be implemented in sub classes depending we want  stochastic mortality
#or deterministic mortality.
#Deterministic will be the first choice. In this case the intensity of mortality
#and intensity of mortality integral paths don't change so they will be calculated
#during initialization and saved into a private field that can be used later on
#( e.g: by  death_time).
#So a sub class for deterministic mortality will have a private field to hold
#the mortality paths and the initialize method must be overwritten to call
#get_mortality() and save the paths once for all. The implementation of death_time
#will be overwritten to get the pre-calculated mortality integrals
#from the private field.
#Sub classes implementing stochastic mortality will have to call get_mortality()
#to get a new simulated path each time.
#In this case the base class implementation of death_time
#does not need to be changed.
#The pricer will pass the death time to the cash_flows method of the VA product
#so that it will return the cash_flows up to death time.
######################END DESIGN  COMMENTS#####################################

#' Generic Variable Annuity  pricer engine
#' @description  Class providing an interface for a generic VA pricer engine.\cr
#' This class shouldn't be instantiated but used as base class for variable annuity
#' pricer engines.  It implements the static approach to estimate the value of a VA
#' contract by means of the Monte Carlo method and the mixed approach by means
#' of Least Squares Monte Carlo.\cr
#' See \bold{References} for a description of the mixed and static approaches and
#' Least Squares Monte Carlo.
#' @docType class
#' @importFrom R6 R6Class
#' @importClassesFrom timeDate timeDate
#' @importFrom timeDate timeDate timeSequence
#' @importFrom orthopolynom laguerre.polynomials
#' @importFrom polynom polynomial
#' @importFrom RcppEigen fastLmPure
#' @export
#' @return Object of \code{\link{R6Class}}
#' @format \code{\link{R6Class}} object.
#' @field the_product (\code{private}) A \code{\link{va_product}} object with
#' the VA contract.
#' @section Methods:
#' \describe{
#'  \item{\code{new}}{Constructor method}
#'  \item{\code{get_mortality}}{Returns the integrals of the intensity of
#'  mortality along the product time-line. It is not implemented in
#'   this base class.}
#'  \item{\code{death_time}}{Returns the time of death index. If the
#'  death doesn't occur during the product time-line it returns the
#'  last index of the product time-line}
#'  \item{\code{simulate_financial_paths}}{Simulates \code{npaths} paths
#'  of the underlying fund of the VA contract and the discount factors (interest
#'   rate). This must be implemented in a sub-class.}
#'  \item{\code{get_fund}}{Gets the \code{i}-th path of the underlying fund where
#'   \code{i} goes from 1 to \code{npaths}. This method must be implemented
#'   by sub-classes}
#'  \item{\code{do_static}}{Estimates the VA contract value by means of
#'  the static approach (Monte Carlo), see \bold{References}. It takes as
#'  arguments:
#'   \describe{
#'     \item{\code{the_gatherer}}{\code{\link{gatherer}} object to hold
#'     the point estimates}
#'     \item{\code{npaths}}{positive integer with the number of paths to
#'     simulate}
#'     \item{\code{simulate}}{boolean to specify if the paths should be
#'     simulated from scratch, default is TRUE.}
#'   }
#'  }
#'  \item{\code{do_mixed}}{Estimates the VA contract by means of
#'  the mixed approach (Least Squares Monte Carlo), see \bold{References}.
#'  It takes as arguments:
#'   \describe{
#'    \item{\code{the_gatherer}}{\code{\link{gatherer}} object to hold
#'     the point estimates}
#'     \item{\code{npaths}}{positive integer with the number of paths to
#'     simulate}
#'     \item{\code{degree}}{positive integer with the maximum degree of
#'     the weighted Laguerre polynomials used in the least squares by LSMC}
#'     \item{\code{freq}}{string which contains the frequency of the surrender
#'     decision. The default is \code{"3m"} which corresponds to deciding every
#'     three months if surrendering the contract or not.}
#'     \item{\code{simulate}}{boolean to specify if the paths should be
#'     simulated from scratch, default is TRUE.}
#'   }
#'  }
#'  \item{\code{get_discount}}{Arguments are \code{i,j}.
#'  Gets the \code{j}-th discount factor corresponding to the \code{i}-th
#'  simulated path of the discount factors. This method must be implemented
#'  by sub-classes.}
#'  \item{\code{bases}}{Interface to get Laguerre polynomials of  state variables.
#'  It is implemented in sub-classes since state variables may differ depending
#'  on the dynamics of financial and mortality processes.
#'  For example if we're modeling just the undelying fund as a
#'  stochastic process (all rest deterministic), the state variable
#'  process will be just the fund, no need to include interest rate or mortality.
#'  \cr
#'  Arguments are:
#'  \describe{
#'   \item{\code{paths}}{numeric vector of indexes of the financial path processes}
#'   \item{\code{time}}{numeric scalar with the time index}
#'   \item{\code{degree}}{positive scalar with the max degree of the Laguerre
#'  polynomials}
#'   }
#'  }
#' }
#' @references
#' \enumerate{
#'  \item{\cite{ Bacinello A.R., Millossovich P., Olivieri A., Pitacco  E.,
#'  "Variable annuities: a unifying valuation approach."
#'  In: Insurance: Mathematics and Economics 49 (2011), pp. 285-297.
#' }}
#'  \item{\cite{Longstaff F.A. e Schwartz E.S. Valuing american options by simulation:
#'  a simple least-squares approach. In: Review of Financial studies
#'  14 (2001), pp. 113-147}}
#'  }


va_engine <- R6Class("va_engine",
 public = list(
  initialize = function(product, ...){

   if(!missing(product))
    if (inherits(product, "va_product")) {
     private$the_product <- product
    } else stop(error_msg_1(" va_product"))
   else stop(error_msg_1(" va_product"))

  },
  simulate_mortality_paths = function(npaths){

  },
  death_time = function(i){

  },
  simulate_financial_paths = function(npaths){

  },
  get_fund = function(i) {

  },
  do_static = function(the_gatherer, npaths, simulate = TRUE){
   #Estimates the VA by means of the static approach
   #implemented with Monte Carlo
   times <- private$the_product$get_times()
   m = length(times)
   ind <- seq(npaths)

   if(simulate){
    #Simulates financials
    self$simulate_financial_paths(npaths)
    #Simulates mortality paths
    self$simulate_mortality_paths(npaths)
    #Simulates times of death
    private$tau <- sapply(ind, function(i){
     self$death_time(i)
    })
   }

   #Initial cash flow matrix
   cash <- matrix(NA, nrow = npaths, ncol = m)
   old_penalty <- private$the_product$get_penalty()
   private$the_product$set_penalty(penalty = 1)
   for (i in ind){
    cash[i, ] <- private$the_product$cash_flows(self$get_fund(i),
                                                private$tau[i])
   }
   res <- sapply(ind, function(i){
     sum(cash[i, 1:private$tau[i]] *
           self$get_discount(i, 1:private$tau[i]))
   })
   private$the_product$set_penalty(penalty = old_penalty)
   the_gatherer$dump_result(res)
  },
  do_mixed = function(the_gatherer, npaths, degree = 3, freq = "3m", simulate = TRUE){
   #Estimates the VA by means of the mixed approach
   #implemented with Least Squares Monte Carlo
   times <- private$the_product$get_times()
   m = length(times)
   ind <- seq(npaths)
   if(simulate){
   #Simulates financials
   self$simulate_financial_paths(npaths)
   #Simulates mortality paths
   self$simulate_mortality_paths(npaths)
   #Simulates times of death
   private$tau <- sapply(ind, function(i){
     self$death_time(i)
   })
   }
   #Initial cash flow matrix
   cash <- matrix(NA, nrow = npaths, ncol = m)
   for (i in ind){
     cash[i, ] <- private$the_product$cash_flows(self$get_fund(i),
                                                 private$tau[i])
   }

   #Initial surrender times vector
   sur_ts <- private$tau
   ##
   surrender_times <- private$the_product$surrender_times(freq)
   survival_times <- private$the_product$survival_benefit_times()
   tt <- c(surrender_times, survival_times)
   #Sets all zero in the cash flow matrix but for times corresponding
   #to surrender decision, living benefit times and death-times.
   for(i in ind) cash[i, -sort(unique(c(tt, private$tau[i])))] <- 0

   for(t in rev(surrender_times)){
     h_t <- which(private$tau > t)
     #Continuation value at time t
     c_t <- sapply(h_t, function(i){
       sum(cash[i, (t+1):sur_ts[i]] *
        self$get_discount(i, (t+1):sur_ts[i]) / self$get_discount(i, t))
       })
     #### Regression ####
     #Regressors
     x_t <- private$bases(h_t, t, degree)
     #Estimated continuation values
     chat_t <- RcppEigen::fastLmPure(x_t, c_t)$fitted.values
     #### Comparison between surrender values and estimated
     #### continuation values ####
     for (i in seq_along(h_t)){
      surv_ben <- private$the_product$survival_benefit(self$get_fund(h_t[i]), t)
      surrender <-  cash[h_t[i], t] - surv_ben
      if (surrender > chat_t[i])
       sur_ts[h_t[i]] <- t
      else cash[h_t[i], t] <- surv_ben
     }
   }
   res <- sapply(seq_along(sur_ts), function(i) {
     sum(cash[i, 1:sur_ts[i]] *
       self$get_discount(i, 1:sur_ts[i]))
     })
   the_gatherer$dump_result(res)
  },
  get_discount = function(i, j) {

    }
 ),
 private = list(
  the_product = "va_product",
  tau = "numeric",
  bases = function(paths, time, degree){
    NULL
  }
 )
)


#

#' Variable Annuity  pricer engine with GBM
#' @description
#' Class providing a variable annuity pricing engine with the underlying
#' reference risk neutral fund modeled as a Geometric Brownian Motion and the
#' intensity of mortality  modeled by the Weibull intensity of mortality.
#' It implements the static approach to estimate the value of a VA
#' contract by means of the Monte Carlo method and the mixed approach by means
#' of Least Squares Monte Carlo.\cr
#' See \bold{References} for a description of the mixed and static approaches and
#' Least Squares Monte Carlo.
#' @docType class
#' @importFrom R6 R6Class
#' @importClassesFrom timeDate timeDate
#' @importFrom timeDate timeDate timeSequence
#' @importFrom orthopolynom laguerre.polynomials
#' @importFrom polynom polynomial
#' @importFrom RcppEigen fastLmPure
#' @export
#' @return Object of \code{\link{R6Class}}
#' @format \code{\link{R6Class}} object.
#' @field the_product (\code{private}) A \code{\link{va_product}} object with
#' the VA contract.
#' @field times (\code{private}) \code{\link{timeDate}} object with the product time-line
#' @field r (\code{private}) \code{\link{parameters}} object with the risk-neutral interest rate
#' @field drifts (\code{private}) \code{numeric} vector with the drifts of the underlying
#' fund.
#' @field standard_deviations (\code{numeric}) vector with the standard_deviations of the
#' underlying fund.
#' @field spot (\code{numeric}) numeric scalar with the initial value of the underlying fund
#' @field mu_integrals (\code{numeric}) vector with the integrals along the product
#' time-line of the intensity of mortality
#' @field fund (\code{matrix}) with  simulated paths of the underlying fund
#' @field discounts (\code{numeric}) vector with the discount factors
#' @field mu_1,mu_2 (\code{numeric}) scalars with the parameters for the Weibull
#' intensity of mortality
#' @section Methods:
#' \describe{
#'  \item{\code{new}}{Constructor method}
#'  \item{\code{get_mortality}}{Returns the integrals of the intensity of
#'  mortality along the product time-line.}
#'  \item{\code{death_time}}{Returns the time of death index. If the
#'  death doesn't occur during the product time-line it returns the
#'  last index of the product time-line.}
#'  \item{\code{simulate_financial_paths}}{Simulates \code{npaths} paths
#'  of the underlying fund of the VA contract and the discount factors (interest
#'   rate). It saves the paths into the \code{fund} matrix and
#'   the \code{discounts} vector.}
#'  \item{\code{get_fund}}{Gets the \code{i}-th path of the underlying fund where
#'   \code{i} goes from 1 to \code{npaths}.}
#'  \item{\code{do_static}}{Estimates the VA contract value by means of
#'  the static approach (Monte Carlo), see \bold{References}. It takes as
#'  arguments:
#'   \describe{
#'     \item{\code{the_gatherer}}{\code{\link{gatherer}} object to hold
#'     the point estimates}
#'     \item{\code{npaths}}{positive integer with the number of paths to
#'     simulate}
#'     \item{\code{simulate}}{boolean to specify if the paths should be
#'     simulated from scratch, default is TRUE.}
#'   }
#'  }
#'  \item{\code{do_mixed}}{Estimates the VA contract by means of
#'  the mixed approach (Least Squares Monte Carlo), see \bold{References}.
#'  It takes as arguments:
#'   \describe{
#'    \item{\code{the_gatherer}}{\code{\link{gatherer}} object to hold
#'     the point estimates}
#'     \item{\code{npaths}}{positive integer with the number of paths to
#'     simulate}
#'     \item{\code{degree}}{positive integer with the maximum degree of
#'     the weighted Laguerre polynomials used in the least squares by LSMC}
#'     \item{\code{freq}}{string which contains the frequency of the surrender
#'     decision. The default is \code{"3m"} which corresponds to deciding every
#'     three months if surrendering the contract or not.}
#'     \item{\code{simulate}}{boolean to specify if the paths should be
#'     simulated from scratch, default is TRUE.}
#'   }
#'  }
#'  \item{\code{get_discount}}{Arguments are \code{i,j}.
#'  Gets the \code{j}-th discount factor corresponding to the \code{i}-th
#'  simulated path of the discount factors.}
#'  \item{\code{bases}}{Interface to get Laguerre polynomials of  state variables.
#'  It is implemented in sub-classes since state variables may differ depending
#'  on the dynamics of financial and mortality processes.
#'  For example if we're modeling just the undelying fund as a
#'  stochastic process (all rest deterministic), the state variable
#'  process will be just the fund, no need to include interest rate or mortality.
#'  \cr
#'  Arguments are:
#'  \describe{
#'   \item{\code{paths}}{numeric vector of indexes of the financial path processes}
#'   \item{\code{time}}{numeric scalar with the time index}
#'   \item{\code{degree}}{positive scalar with the max degree of the Laguerre
#'  polynomials}
#'   }
#'  }
#' }
#' @references
#' \enumerate{
#'  \item{\cite{ Bacinello A.R., Millossovich P., Olivieri A., Pitacco  E.,
  #'  "Variable annuities: a unifying valuation approach."
  #'  In: Insurance: Mathematics and Economics 49 (2011), pp. 285-297.
  #' }}
#'  \item{\cite{Longstaff F.A. e Schwartz E.S. Valuing american options by simulation:
  #'  a simple least-squares approach. In: Review of Financial studies
  #'  14 (2001), pp. 113-147}}
#'  }
#'@usage
#'contract <- GMAB$new(rollup, times, age, fee, barrier, penalty)
#'
#'r <- constant_parameters$new(0.01)
#'spot <- 100
#'vol <- constant_parameters$new(0.2)
#'div <- constant_parameters$new(0.0)
#'
#'gatherer_mean <- statistics_mean$new()
#'no_of_paths <- 1e4
#'
#'engine <- va_bs_engine$new(contract, r, c1=90.43, c2=10.36, spot, volatility=vol, dividends=div)
#'
#'#Estimates the contract value by means of the static approach.
#'
#'engine$do_static(gatherer_mean, no_of_paths)
#'gatherer_mean$get_results()
#'
#'#Estimates the contract value by means of the mixed approach.
#'#To compare with the static approach we won't simulate the underlying
#'#fund paths again.
#'
#'gatherer_mean_2 <- statistics_mean$new()
#'
#'engine$do_mixed(gatherer_mean_2, no_of_paths, degree = 3, freq = "3m", simulate = FALSE)
#'gatherer_mean_2$get_results()




va_bs_engine <- R6::R6Class("va_bs_engine", inherit = va_engine,
 public = list(
  initialize = function(product, interest, c1, c2, spot, volatility, dividends){
   if(!missing(product))
    if (inherits(product, "va_product")){
     private$the_product <- product
     private$times <- product$get_times()
     private$no_time_intervals <- length(private$times) - 1
     private$drifts <- numeric(private$no_time_intervals)
     private$standard_deviations <- numeric(private$no_time_intervals)
     private$variates <- numeric(private$no_time_intervals)
    } else stop(error_msg_1("va_product"))
   else stop(error_msg_1("va_product"))

   if(!missing(interest))
    if(inherits(interest, "parameters")){
     private$r <- interest
    } else stop(error_msg_1("parameters"))
   else stop(error_msg_1("parameters"))

   if(!missing(c1))
    if (is_positive_scalar(c1))
      private$mu_1 <- c1
    else stop(error_msg_5("c1"))
   else private$mu_1 <- 90.43

   if(!missing(c2))
    if(is_positive_scalar(c2))
      private$mu_2 <- c2
    else stop(error_msg_5("c2"))
   else private$mu_2 <- 10.36

   if(!missing(spot))
    if (is_positive_scalar(spot)){
     private$spot <- spot
    } else stop(error_msg_3)
   else stop(error_msg_3)

   if(!missing(volatility) & !missing(dividends)){
    if (inherits(volatility, "parameters") & inherits(dividends, "parameters")){
     for (j in seq(private$no_time_intervals)){
      this_variance <- volatility$integral_square(private$times[j], private$times[j+1])
      private$drifts[j] <- interest$integral(private$times[j], private$times[j+1])
      - dividends$integral(private$times[j], private$times[j+1])
      - 0.5 * this_variance
      private$standard_deviations[j] <- sqrt(this_variance)
     }
    }else stop(error_msg_2("parameters"))
   } else stop(error_msg_2("parameters"))

   private$mu_integrals <- self$simulate_mortality_paths()
  },
  simulate_financial_paths = function(npaths){
    cf_times <- private$the_product$get_times()
    private$fund <- t(vapply(seq(npaths), function(index) {
      private$simulate_financial_path()
    }, FUN.VALUE = vector("numeric", length(cf_times))))
    t0 <- cf_times[1]
    log_discounts <- sapply(cf_times, function(t) -private$r$integral(t0, t))
    private$discounts <- exp(log_discounts)
  },
  get_fund = function(i) private$fund[i, ],
  get_discount = function(i,j) private$discounts[j],
  simulate_mortality_paths = function(npaths){
    age <- private$the_product$get_age()
    c1 <- private$mu_1
    c2 <- private$mu_2
    t_yrs  <- head(private$the_product$times_in_yrs(), -1)
    #Deterministic intensity of mortality ( Weibull )
    mu <- (c1 ^ (-c2)) * c2 * ((age + t_yrs) ^ (c2 - 1))
    #Integrals of the intensity of mortality
    dt <- diff(t_yrs)
    mu_ <- head(mu, -1)
    mu_integrals <- cumsum(c(0, mu_ * dt))
    mu_integrals
  },
  death_time = function(i){
    ind <- which(private$mu_integrals > rexp(1))
    if (length(ind) != 0)
      res <- min(ind)
    else res <- length(private$times)
    res
  }
 ),
 private = list(
  times = "timeDate",
  r = "parameters",
  drifts = "numeric",
  standard_deviations = "numeric",
  variates = "numeric",
  spot = "numeric",
  no_time_intervals = "numeric",
  mu_integrals = "numeric",
  fund = "matrix",
  discounts = "numeric",
  #Intensity of mortality parameters
  mu_1 = 90.43,
  mu_2 = 10.36,
  simulate_financial_path = function(){
    private$variates <- rnorm(private$no_time_intervals)
    current_log_spot <- private$drifts +
      private$standard_deviations * private$variates
    current_log_spot <- cumsum(current_log_spot)
    c(spot, spot*exp(current_log_spot))
  },
  bases = function(paths, time, degree){

    res <- orthopolynom::laguerre.polynomials(degree, normalized = TRUE)
    x <- private$fund[paths, time]
    #Normalizes to avoid underflows in calculating
    #the exponential below.
    x <- x / private$the_product$get_premium()

    sapply(seq_along(res), function(i){
      exp(-0.5 * x) * (as.function(res[[i]])(x))
    })
  }
 )
)


